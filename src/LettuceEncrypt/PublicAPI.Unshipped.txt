#nullable enable
LettuceEncrypt.IAcmeCertificateLoader
LettuceEncrypt.IAcmeCertificateLoader.IsRunning.get -> bool
LettuceEncrypt.IAdditionalIssuersSource
LettuceEncrypt.IAdditionalIssuersSource.GetAdditionalIssuersAsync(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Certificate2!>!>!
LettuceEncrypt.IDomainCert
LettuceEncrypt.IDomainCert.Domains.get -> System.Collections.Generic.ISet<string!>!
LettuceEncrypt.IDomainLoader
LettuceEncrypt.IDomainLoader.GetDomainCertsAsync(System.Threading.CancellationToken cancellationToken, bool refreshCache = false) -> System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<LettuceEncrypt.IDomainCert!>!>!
LettuceEncrypt.IDomainSource
LettuceEncrypt.IDomainSource.GetDomains(System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<System.Collections.Generic.ISet<LettuceEncrypt.IDomainCert!>!>!
LettuceEncrypt.MultipleDomainCert
LettuceEncrypt.MultipleDomainCert.Domains.get -> System.Collections.Generic.ISet<string!>!
LettuceEncrypt.MultipleDomainCert.MultipleDomainCert() -> void
LettuceEncrypt.MultipleDomainCert.OrderedDomains.get -> System.Collections.Generic.HashSet<string!>!
LettuceEncrypt.MultipleDomainCert.OrderedDomains.set -> void
LettuceEncrypt.SingleDomainCert
LettuceEncrypt.SingleDomainCert.Domain.get -> string!
LettuceEncrypt.SingleDomainCert.Domain.set -> void
LettuceEncrypt.SingleDomainCert.Domains.get -> System.Collections.Generic.ISet<string!>!
LettuceEncrypt.SingleDomainCert.SingleDomainCert() -> void
LettuceEncrypt.IHttpChallengeResponseStore
LettuceEncrypt.IHttpChallengeResponseStore.AddChallengeResponse(string! token, string! response) -> void
LettuceEncrypt.IHttpChallengeResponseStore.TryGetResponse(string! token, out string? value) -> bool
LettuceEncrypt.IRuntimeCertificateStore
LettuceEncrypt.IRuntimeCertificateStore.AddCertWithDomainName(string! domainName, System.Security.Cryptography.X509Certificates.X509Certificate2! certificate) -> System.Security.Cryptography.X509Certificates.X509Certificate2!
LettuceEncrypt.IRuntimeCertificateStore.AddChallengeCertWithDomainName(string! domainName, System.Security.Cryptography.X509Certificates.X509Certificate2! certificate) -> System.Security.Cryptography.X509Certificates.X509Certificate2!
LettuceEncrypt.IRuntimeCertificateStore.AnyChallengeCert() -> bool
LettuceEncrypt.IRuntimeCertificateStore.ContainsCertForDomain(string! domainName) -> bool
LettuceEncrypt.IRuntimeCertificateStore.GetAllCertDomains() -> System.Collections.Generic.IEnumerable<string!>!
LettuceEncrypt.IRuntimeCertificateStore.GetCert(string! domainName, out System.Security.Cryptography.X509Certificates.X509Certificate2? certificate) -> bool
LettuceEncrypt.IRuntimeCertificateStore.GetChallengeCert(string! domainName, out System.Security.Cryptography.X509Certificates.X509Certificate2? certificate) -> bool
LettuceEncrypt.IRuntimeCertificateStore.RemoveCert(string! domainName) -> bool
LettuceEncrypt.IRuntimeCertificateStore.RemoveChallengeCert(string! domainName) -> bool
